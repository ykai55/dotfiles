#!/usr/bin/env python3
from __future__ import annotations

import argparse
import datetime
import hashlib
import json
import os
import shutil
import subprocess
import sys
import tempfile
from typing import Any, Dict, List, Optional, Tuple


def run_cmd(argv: List[str]) -> Tuple[int, str, str]:
    proc = subprocess.run(argv, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    return proc.returncode, proc.stdout, proc.stderr


def tool_path(name: str) -> str:
    local = os.path.join(os.path.dirname(__file__), name)
    if os.path.isfile(local) and os.access(local, os.X_OK):
        return local
    return name


def data_dir() -> str:
    env_dir = os.environ.get("TBOX_DIR")
    if env_dir:
        return os.path.abspath(os.path.expanduser(env_dir))
    base = os.environ.get("XDG_DATA_HOME")
    if not base:
        base = os.path.expanduser("~/.local/share")
    return os.path.join(base, "tmux-box")


def current_session_name() -> Optional[str]:
    rc, out, _ = run_cmd(["tmux", "display-message", "-p", "#{session_name}"])
    if rc != 0:
        return None
    name = out.strip()
    return name or None


def session_name_from_dump(data: Dict[str, Any]) -> Optional[str]:
    if "sessions" in data and isinstance(data.get("sessions"), list):
        sessions = data.get("sessions") or []
        if not sessions:
            return None
        session = sessions[0] or {}
        return session.get("name") or session.get("session_name")
    if "windows" in data or "name" in data or "session_name" in data:
        return data.get("name") or data.get("session_name")
    return None


def windows_count_from_dump(data: Dict[str, Any]) -> Optional[int]:
    if "sessions" in data and isinstance(data.get("sessions"), list):
        sessions = data.get("sessions") or []
        if not sessions:
            return None
        session = sessions[0] or {}
        windows = session.get("windows") or []
        if isinstance(windows, list):
            return len(windows)
        return None
    windows = data.get("windows") or []
    if isinstance(windows, list):
        return len(windows)
    return None


def safe_filename(session_name: str) -> str:
    clean = "".join(ch if (ch.isalnum() or ch in "._-") else "_" for ch in session_name)
    if not clean:
        clean = "session"
    digest = hashlib.sha1(session_name.encode("utf-8")).hexdigest()[:8]
    return f"{clean}-{digest}.json"


def load_saved_sessions(store_dir: str) -> List[Dict[str, Any]]:
    if not os.path.isdir(store_dir):
        return []
    entries: List[Dict[str, Any]] = []
    for name in os.listdir(store_dir):
        if not name.endswith(".json"):
            continue
        path = os.path.join(store_dir, name)
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception as exc:
            print(f"WARN: failed to read {path}: {exc}", file=sys.stderr)
            continue
        session_name = session_name_from_dump(data) or name
        windows_count = windows_count_from_dump(data)
        try:
            mtime = os.path.getmtime(path)
        except OSError:
            mtime = 0.0
        entries.append(
            {
                "name": str(session_name),
                "path": path,
                "mtime": mtime,
                "windows_count": windows_count,
            }
        )
    entries.sort(key=lambda e: e.get("mtime", 0.0), reverse=True)
    return entries


def find_entry_by_name(entries: List[Dict[str, Any]], name: str) -> Optional[Dict[str, Any]]:
    for entry in entries:
        if entry.get("name") == name:
            return entry
    return None


def tmux_has_session(name: str) -> bool:
    rc, _, _ = run_cmd(["tmux", "has-session", "-t", name])
    return rc == 0


def unique_session_name(base: str) -> str:
    if not tmux_has_session(base):
        return base
    idx = 1
    while True:
        candidate = f"{base}({idx})"
        if not tmux_has_session(candidate):
            return candidate
        idx += 1


def format_mtime(ts: float) -> str:
    if not ts:
        return ""
    return datetime.datetime.fromtimestamp(ts).strftime("%Y-%m-%d %H:%M")


def choose_entry(entries: List[Dict[str, Any]], prompt: str) -> Optional[Dict[str, Any]]:
    if not entries:
        return None

    fzf = shutil.which("fzf")
    sk = shutil.which("sk")
    selector = fzf or sk
    entry_map = {e["path"]: e for e in entries}

    name_width = max(len(str(entry.get("name", ""))) for entry in entries)
    windows_width = max(
        len(f"{entry.get('windows_count')}w") if entry.get("windows_count") is not None else 2
        for entry in entries
    )
    mtime_width = max(len(format_mtime(entry.get("mtime", 0.0))) for entry in entries)

    lines: List[str] = []
    for entry in entries:
        raw_name = str(entry.get("name", "")).replace("\t", " ")
        name = raw_name.ljust(name_width)
        windows = entry.get("windows_count")
        windows_label = f"{windows}w" if windows is not None else ""
        windows_pad = windows_label.ljust(windows_width)
        mtime = format_mtime(entry.get("mtime", 0.0))
        mtime_pad = mtime.ljust(mtime_width)
        lines.append(f"{name}\t{windows_pad}\t{mtime_pad}\t{entry['path']}")

    if selector:
        cmd = [selector, "--prompt", f"{prompt}: ", "--with-nth", "1,2,3", "--delimiter", "\t"]
        proc = subprocess.run(
            cmd,
            input="\n".join(lines) + "\n",
            text=True,
            stdout=subprocess.PIPE,
        )
        if proc.returncode != 0:
            return None
        selected = proc.stdout.strip()
        if not selected:
            return None
        path = selected.split("\t")[-1].strip()
        return entry_map.get(path)

    for idx, entry in enumerate(entries, start=1):
        windows = entry.get("windows_count")
        windows_label = f"{windows}w" if windows is not None else "?w"
        name = str(entry.get("name", "")).ljust(name_width)
        windows_pad = windows_label.ljust(windows_width)
        mtime = format_mtime(entry.get("mtime", 0.0)).ljust(mtime_width)
        print(f"{idx}) {name}  {windows_pad}  {mtime}".rstrip())

    selection = input(f"{prompt} (number): ").strip()
    if not selection:
        return None
    try:
        idx = int(selection)
    except ValueError:
        return None
    if idx < 1 or idx > len(entries):
        return None
    return entries[idx - 1]


def cmd_save(name: Optional[str]) -> int:
    target = name
    if not target:
        if not os.environ.get("TMUX"):
            print("ERROR: name is required when not inside tmux", file=sys.stderr)
            return 2
        target = current_session_name()
    if not target:
        print("ERROR: name is required when not inside tmux", file=sys.stderr)
        return 2

    store = data_dir()
    os.makedirs(store, exist_ok=True)

    entries = load_saved_sessions(store)
    existing = find_entry_by_name(entries, target)
    dest_path = existing["path"] if existing else os.path.join(store, safe_filename(target))

    tmp_fd, tmp_path = tempfile.mkstemp(prefix=".tbox-", suffix=".json", dir=store)
    os.close(tmp_fd)

    cmd = [tool_path("tmux-dump"), "--session", target, tmp_path]
    rc, _, err = run_cmd(cmd)
    if rc != 0:
        if err:
            print(err.strip(), file=sys.stderr)
        else:
            print("ERROR: tmux-dump failed", file=sys.stderr)
        try:
            os.remove(tmp_path)
        except OSError:
            pass
        return 1

    os.replace(tmp_path, dest_path)
    print(f"Saved session '{target}'")
    return 0


def cmd_select(run_commands: bool, new_session: bool) -> int:
    store = data_dir()
    entries = load_saved_sessions(store)
    if not entries:
        print("ERROR: no stored sessions", file=sys.stderr)
        return 1

    entry = choose_entry(entries, "Select session")
    if not entry:
        return 1

    cmd = [tool_path("tmux-load"), entry["path"]]
    if new_session:
        try:
            with open(entry["path"], "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception as exc:
            print(f"ERROR: failed to read dump file: {exc}", file=sys.stderr)
            return 1
        base_name = session_name_from_dump(data) or entry.get("name") or "session"
        target = unique_session_name(str(base_name))
        cmd.extend(["--session", target])
    if not run_commands:
        cmd.append("--no-run-commands")
    return subprocess.run(cmd).returncode


def cmd_drop(name: Optional[str]) -> int:
    if not name:
        if not os.environ.get("TMUX"):
            print("ERROR: name is required when not inside tmux", file=sys.stderr)
            return 2
        name = current_session_name()
    if not name:
        print("ERROR: name is required when not inside tmux", file=sys.stderr)
        return 2

    store = data_dir()
    entries = load_saved_sessions(store)
    if not entries:
        print("ERROR: no stored sessions", file=sys.stderr)
        return 1

    entry = find_entry_by_name(entries, name)
    if not entry:
        print(f"ERROR: no stored session named '{name}'", file=sys.stderr)
        return 1

    try:
        os.remove(entry["path"])
    except OSError as exc:
        print(f"ERROR: failed to remove {entry['path']}: {exc}", file=sys.stderr)
        return 1
    print(f"Removed session '{name}'")
    return 0


def cmd_list(verbose: bool) -> int:
    store = data_dir()
    entries = load_saved_sessions(store)
    if not entries:
        print("No stored sessions")
        return 1

    name_width = max(len(str(entry.get("name", ""))) for entry in entries)
    windows_width = max(
        len(f"{entry.get('windows_count')}w") if entry.get("windows_count") is not None else 2
        for entry in entries
    )
    mtime_width = max(len(format_mtime(entry.get("mtime", 0.0))) for entry in entries)

    for entry in entries:
        windows = entry.get("windows_count")
        windows_label = f"{windows}w" if windows is not None else "?w"
        mtime = format_mtime(entry.get("mtime", 0.0))
        name = str(entry.get("name", "")).ljust(name_width)
        windows_pad = windows_label.ljust(windows_width)
        mtime_pad = mtime.ljust(mtime_width)
        line = f"{name}  {windows_pad}  {mtime_pad}".rstrip()
        if verbose:
            line = f"{line}  {entry['path']}"
        print(line)
    return 0


def main() -> int:
    parser = argparse.ArgumentParser(description="tmux session persistence manager")
    subparsers = parser.add_subparsers(dest="command")

    save_parser = subparsers.add_parser("save", help="Save current tmux session")
    save_parser.add_argument("name", nargs="?", help="Target tmux session name")

    select_parser = subparsers.add_parser("select", help="Select and restore a stored session")
    select_parser.add_argument(
        "--no-run-commands",
        action="store_false",
        dest="run_commands",
        help="Do not run pane commands during restore",
    )
    select_parser.add_argument(
        "--new",
        action="store_true",
        help="Restore into a new tmux session",
    )
    select_parser.set_defaults(run_commands=True, new=False)
    drop_parser = subparsers.add_parser("drop", help="Drop a stored session")
    drop_parser.add_argument("name", nargs="?", help="Stored session name")
    list_parser = subparsers.add_parser("list", help="List stored sessions")
    list_parser.add_argument("-v", "--verbose", action="store_true", help="Show dump file path")

    args = parser.parse_args()
    if args.command == "save":
        return cmd_save(args.name)
    if args.command == "select":
        return cmd_select(args.run_commands, args.new)
    if args.command == "drop":
        return cmd_drop(args.name)
    if args.command == "list":
        return cmd_list(args.verbose)

    parser.print_help()
    return 2


if __name__ == "__main__":
    raise SystemExit(main())
